<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engineering Portfolio</title>
    <style>
        /* --- CSS STYLES --- */
        :root {
            --primary-color: #0a0a0a;
            --accent-color: #067a10;
            --bg-color: #ccc5c0;
            --text-color: #0a0a0a;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        .container {
            max-width: 850px;
            margin: 40px auto;
            padding: 40px;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
            border-radius: 8px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }

        h1 { margin-bottom: 5px; color: var(--primary-color); }
        p.subtitle { color: #666; margin-top: 0; font-size: 1.1em; }
        .contact-info { font-size: 0.9em; color: #888; margin-top: 10px; }
        .contact-info a { color: var(--accent-color); text-decoration: none; margin: 0 10px; }

        /* Navigation Tabs Styles */
        .tabs {
            display: flex;
            justify-content: center;
            border-bottom: 2px solid #ddd;
            margin-bottom: 30px;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #777;
            transition: 0.3s;
        }

        .tab-button:hover { color: var(--accent-color); }

        .tab-button.active {
            color: var(--accent-color);
            border-bottom: 3px solid var(--accent-color);
            margin-bottom: -2px;
        }

        /* Content Sections */
        .content-section {
            display: none; /* Hidden by default */
            animation: fadeIn 0.4s;
        }

        .content-section.active {
            display: block; /* Shown when active */
        }

        h2 { color: var(--primary-color); border-bottom: 2px solid #eee; padding-bottom: 10px; margin-top: 30px;}

        /* Resume Specific Styles */
        .resume-item {
            margin-bottom: 25px;
            border-left: 4px solid var(--accent-color);
            padding-left: 20px;
        }
        
        .resume-item h3 { margin-bottom: 5px; margin-top: 0; }
        .resume-date { font-size: 0.9em; color: #666; font-style: italic; margin-bottom: 10px; display: block; }
        
        ul { margin-top: 5px; padding-left: 20px; }
        li { margin-bottom: 5px; }

        .skills-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .skill-tag {
            background: #eef2f5;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #555;
            border: 1px solid #ddd;
        }

        /* Code Block Styles */
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            border: 1px solid #333;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Dhruba Bhattacharjee</h1>
        <p class="subtitle">Computer Engineering Student | AI/ML, Robotics, Embedded Systems</p>
        <div class="contact-info">

            <a href="mailto:dhruba@vt.edu">dhruba@vt.edu</a> | 
            <a href="https://linkedin.com/in/dhrubabhattacharjee" target="_blank">LinkedIn</a> |
            <a href="https://github.com/ScienceByte" target="_blank">Github</a> 

        </div>
    </header>

    <div class="tabs">
        <button class="tab-button" onclick="openTab(event, 'resume')">Resume</button>
        <button class="tab-button active" onclick="openTab(event, 'code')">Code Samples</button>
    </div>

    <!-- RESUME TAB -->
    <div id="resume" class="content-section">
        
        <h2>Education</h2>
        <div class="resume-item">
            <h3>Virginia Tech</h3>
            <span class="resume-date">B.S. Computer Engineering (Expected 2027) | Blacksburg, VA</span>
            <p>Relevant Coursework: Interdisciplinary Design, Digital Systems, Embedded Systems, Machine Learning.</p>
        </div>




        <h2>Experience & Projects</h2>
        
        <div class="resume-item">
            <h3>HEVT (EcoCAR EV Challenge Team) - CAV Team Member</h3>
            <span class="resume-date">Sept 2025 - Present</span>
            <ul>
                <li>Implemented ROS node and CAN bus fault detection, utilizing Quality of Service profiles to monitor signal latency and dropout.</li>
                <li>Used Foxglove to test with logged data from our Cadillac Lyriq team vehicle.</li>
                <li>Led the fault analysis section within the Fall technical deliverable, across the 40+ member interdisciplinary team.</li>
            </ul>
        </div>

        <div class="resume-item">
            <h3>VT CRO - Autonomous Workcell (3D Printing) Team Member</h3>
            <span class="resume-date">Sept 2024 - Present</span>
            <ul>
                <li>Developed auto-calibration features using Python and OpenCV.</li>
                <li>Trained a YOLOv11 AI model to detect various types of 3D printing failure (e.g., spaghetti, layer shifts).</li>
                <li>Full-Stack development on a web-based queue system, using NodeJS and React.</li>
                <li>Won Honda Innovation Award at National Robotics Challenge.</li>
            </ul>
        </div>

        <div class="resume-item">
            <h3>Odyssey of the Mind</h3>
            <span class="resume-date">Sept 2021 - Jun 2024</span>
            <ul>
                <li>Utilized Fusion360 and 3D printing to design and prototype core components,
  such as a mechanical beating heart prop.</li>
                <li>Achieved 8th place in World Finals.</li>
            </ul>
        </div>

        <div class="resume-item">
            <h3>Automotive Electronics Passion Project</h3>
            <span class="resume-date">Jun 2024 - Jul 2024</span>
            <ul>
                <li>Analyzed wiring diagrams to install an advanced car stereo and backup
                camera on a 2008 Hyundai.</li>
                <li>Fabricated a custom mount to install a retractable touchscreen unit.</li>
                <li>Installed a back-up camera, tapping into reverse lights for automatic triggering.</li>
            </ul>
        </div>


	<h2>Relevant Coursework</h2>
        <div class="resume-item">
            <h3>Interdisciplinary Design Project</h3>
            <ul>
            <li>Created a smart locker system running on a ATmega328P chip, programmed in C++.</li>
	    <li>Implemented power-down modes and servo control without using any additional libraries.</li>
	    </ul>
        </div>
        <div class="resume-item">
            <h3>Digital Systems</h3>
            <p>Designed a functioning 8-bit CPU on an FPGA board using Verilog and Intel Quartus.</p>
        </div>
        <div class="resume-item">
            <h3>Embedded Systems</h3>
            <ul>
            <li>Developed C-based firmware, and custom Hardware Abstraction Layer for TI MSP432 LaunchPad.</li>
	    <li>Wrote drivers to control an LCD, joystick, and UART communication for embedded applications.</li>
	    </ul>
        </div>

        <h2>Leadership & Volunteering</h2>
        <div class="resume-item">
            <h3>Game Dev Club Committee Member</h3>
            <span class="resume-date">Sept 2025 - Present</span>
            <p>Aided in organization of Game Jams and attaining club sponsorship.</p>
        </div>
        <div class="resume-item">
            <h3>Childrenâ€™s Hackathon - Founder & Organizer</h3>
            <span class="resume-date">Aug 2023 - Aug 2024</span>
            <ul>
            <li>Founded a PVSA-certified nonprofit to teach coding fundamentals to kids.</li>
	    <li>Built the event website and recruited volunteers.</li>
	    </ul>
        </div>
        <div class="resume-item">
            <h3>Teaching STEM through a 4-H club - Head Instructor</h3>
            <span class="resume-date">Feb 2022 - Jun 2024</span>
            <p>Designed and taught curriculum on Python, C++, and robotics.</p>
        </div>

        <h2>Skills</h2>
        <div class="resume-item">
            
            <p><b>Languages:</b> Python, C, C++, Javascript, Verilog</p>

            <p><b>Frameworks & Libraries:</b> ROS2, OpenCV, Yolo, React, PyTorch, NodeJS, MATLAB</p>

            <p><b>Hardware:</b> FPGA Circuit Design, Arduino Uno, Soldering, 3D Printer maintenance</p>

            <p><b>Developer Tools:</b> Git, Docker, Linux Environment, Foxglove</p>

            <p><b>Creative:</b> VR Game Development (Godot), Video Editing, 3D Animation, Writing & Acting</p>
        </div>
    </div>

    <!-- CODE TAB -->
    <div id="code" class="content-section active">
        <h2>Code Portfolio</h2>
        <p>A selection of code snippets demonstrating my work.</p>

	<h3>EcoCAR EV Challenge Team (Robotics, ROS2, Python)</h3>

	<p>Semester Project Showcase Slideshow: </p>
	<a href="https://docs.google.com/presentation/d/12R4PyzvMmXPA0fOZaY3Oe2LAbkICr5lxOHPjaV9Bc_A/edit?usp=sharing" target="_blank">https://docs.google.com/presentation/d/12R4PyzvMmXPA0fOZaY3Oe2LAbkICr5lxOHPjaV9Bc_A/edit?usp=sharing</a>
	

	<p><b>ROS Node that contains code to take in relevant ROS topics and send through MQTT to
the Team Data Display on the car dashboard:</b></p>

<pre><code>
import json
import os


import paho.mqtt.client as mqtt
import rclpy
from rclpy.node import Node




from std_msgs.msg import Int32, String, Float64, Bool  # added line and Bool




from rclpy.qos import QoSProfile
from rclpy.duration import Duration
from rclpy.subscription import (
    SubscriptionEventCallbacks,
)  # will be needed for adding specifcially an event-based callback




class HMIStatesNode(Node):
    HMI_STATES = {  # published as  ROS topic for testing with foxglove
        "Dyno Mode Switch": False,
        "DMS Switch": False,
        "AIN Switch": False,
        "AIN Light": False,
        "Vehicle Ahead Light": False,
        "Distance to Lead Vehicle": 0,
        "Headway to Lead Vehicle": 0,
        "Traffic Light State Light": "RED",  # Enum: "RED", "YELLOW", "GREEN"
        "CACC Mileage Accumulation": 0,
        "UDP Simulation Data Received Light": False,
        "Request for Dyno Mode Light": False,
        "Object Injection Simulation Active Light": False,
        "FAULT DETECTION: CAN2 Connected": False,
        "FAULT DETECTION: ACC States Node Connected": False,
        "FAULT DETECTION: ACC Controller Node Connected": False,
        "FAULT DETECTION: CAN8 Connected": False,
        "FAULT DETECTION: EVC CAN Connected": False,
        "FAULT DETECTION: CAN3 Connected": False,
        "FAULT DETECTION: CAN9 Connected": False,
        "DYNO: UDP DATA AVAILABLE": False,
        "DYNO: DYNO REQUESTED": False,
        "DYNO: INJECTION ACTIVE": False,
    }


    INTERFACES = {"Dyno Mode Switch", "DMS Switch", "AIN Switch"}


    # Mapping between frontend keys and full state names
    KEY_MAPPING = {
        "DYNO": "Dyno Mode Switch",
        "DMS": "DMS Switch",
        "AIN": "AIN Switch",
    }


    def __init__(self):
        super().__init__("hmi_states_node")
        self.state = self.HMI_STATES.copy()


        # CAN QoS Profile
        can_qos_profile = QoSProfile(
            depth=10,
            deadline=Duration(seconds=2),  # longer deadline
        )


        # ACC QoS Profile
        acc_qos_profile = QoSProfile(
            depth=10,
            deadline=Duration(seconds=0.3),
        )


        self.can8_fault_subscriber = self.create_subscription(
            String,
            "/can8_acp3_heartbeat",
            self.can8_fault_callback,
            qos_profile=can_qos_profile,
            event_callbacks=SubscriptionEventCallbacks(
                deadline=self.can8_fault_missed_deadline_callback,
            ),
        )


        self.can3_fault_subscriber = self.create_subscription(
            String,
            "/can3_acp3_heartbeat",
            self.can3_fault_callback,
            qos_profile=can_qos_profile,
            event_callbacks=SubscriptionEventCallbacks(
                deadline=self.can3_fault_missed_deadline_callback,
            ),
        )


        self.can9_fault_subscriber = self.create_subscription(
            String,
            "/can9_heartbeat",
            self.can9_fault_callback,
            qos_profile=can_qos_profile,
            event_callbacks=SubscriptionEventCallbacks(
                deadline=self.can9_fault_missed_deadline_callback,
            ),
        )


        self.canevc_fault_subscriber = self.create_subscription(
            Float64,
            "/acc_in/ego_velocity",
            self.canevc_fault_callback,
            qos_profile=can_qos_profile,
            event_callbacks=SubscriptionEventCallbacks(
                deadline=self.canevc_fault_missed_deadline_callback,
            ),
        )


        self.can2_fault_subscriber = self.create_subscription(
            String,  # it's a string not a bool
            "/steering_wheel_angle",
            self.can2_fault_callback,
            qos_profile=can_qos_profile,
            event_callbacks=SubscriptionEventCallbacks(
                deadline=self.can2_fault_missed_deadline_callback,
            ),
        )


        self.create_subscription(
            Float64, "/msg1/sim_state", self.sim_state_callback, 10
        )


        self.sub_dyno_req = self.create_subscription(
            Int32, "/dyno_mode_request", self.dyno_req_callback, 10
        )


        self.subscription_dyno_state = self.create_subscription(
            Int32, "/dyno_state", self.dyno_state_callback, 10
        )


        self.acc_states_fault_subscriber = self.create_subscription(
            Int32,
            "/acc_state",
            self.acc_states_fault_callback,
            qos_profile=acc_qos_profile,
            event_callbacks=SubscriptionEventCallbacks(
                deadline=self.acc_states_fault_missed_deadline_callback,
            ),
        )


        self.acc_controller_fault_subscriber = self.create_subscription(
            Int32,
            "/acc_out/acceleration_flag",
            self.acc_controller_fault_callback,
            qos_profile=acc_qos_profile,
            event_callbacks=SubscriptionEventCallbacks(
                deadline=self.acc_controller_fault_missed_deadline_callback,
            ),
        )


        # MQTT setup
        self.mqtt_client = mqtt.Client()
        self.mqtt_client.on_connect = self.on_connect
        self.mqtt_client.on_message = self.on_message


        mqtt_broker_ip = os.getenv("MQTT_BROKER_IP", "192.168.140.12")


        self.get_logger().info(
            f"HMI MQTT Node starting with broker IP {mqtt_broker_ip}!"
        )
        try:
            self.mqtt_client.connect(mqtt_broker_ip, 1883, 60)
            self.mqtt_client.subscribe("hmi/button_press")
            self.mqtt_client.loop_start()
        except Exception as e:
            self.get_logger().info(f"Unable to connect to TDD. {mqtt_broker_ip}!")


        self.timer = self.create_timer(1.0, self.publish_hmi_states)


        # ROS publisher to view tested HMI states
        self.publisher_hmi_states = self.create_publisher(String, "/HMI_states", 10)


    def can8_fault_callback(self, msg):
        self.get_logger().debug(f"Received CAN8 fault check:")
        self.state["FAULT DETECTION: CAN8 Connected"] = True


    def can8_fault_missed_deadline_callback(self, msg):
        self.get_logger().debug(f"deadline failed for can8 fault check.")
        self.state["FAULT DETECTION: CAN8 Connected"] = False  # connection is lost


    def can3_fault_callback(self, msg):
        self.get_logger().debug(f"Received CAN3 fault check:")
        self.state["FAULT DETECTION: CAN3 Connected"] = True


    def can3_fault_missed_deadline_callback(self, msg):
        self.get_logger().debug(f"deadline failed for can3 fault check.")
        self.state["FAULT DETECTION: CAN3 Connected"] = False  # connection is lost


    def can9_fault_callback(self, msg):
        self.get_logger().debug(f"Received CAN9 fault check:")
        self.state["FAULT DETECTION: CAN9 Connected"] = True


    def can9_fault_missed_deadline_callback(self, msg):
        self.get_logger().debug(f"deadline failed for can9 fault check.")
        self.state["FAULT DETECTION: CAN9 Connected"] = False  # connection is lost


    def canevc_fault_callback(self, msg):
        self.get_logger().debug(f"Received CAN EVC fault check:")
        self.state["FAULT DETECTION: EVC CAN Connected"] = True


    def canevc_fault_missed_deadline_callback(self, msg):
        self.get_logger().debug(f"deadline failed for can evc fault check.")
        self.state["FAULT DETECTION: EVC CAN Connected"] = False  # connection is lost


    def can2_fault_callback(self, msg):
        self.get_logger().debug(f"Received CAN2 fault check:")
        self.state["FAULT DETECTION: CAN2 Connected"] = (
            True  # if we have a normal callback, then we are connected
        )


    def can2_fault_missed_deadline_callback(self, msg):
        self.get_logger().debug(f"deadline failed for can2 fault check.")
        self.state["FAULT DETECTION: CAN2 Connected"] = False  # connection is lost


    def acc_states_fault_callback(self, msg):
        self.get_logger().debug(f"Received ACC States Node fault check:")
        self.state["FAULT DETECTION: ACC States Node Connected"] = (
            True  # if we have a normal callback, then we are connected
        )


    def acc_states_fault_missed_deadline_callback(self, msg):
        self.get_logger().debug(f"deadline failed for ACC States Node fault check.")
        self.state["FAULT DETECTION: ACC States Node Connected"] = (
            False  # connection is lost
        )


    def acc_controller_fault_callback(self, msg):
        self.get_logger().debug(f"Received ACC Controller Node fault check:")
        self.state["FAULT DETECTION: ACC Controller Node Connected"] = (
            True  # if we have a normal callback, then we are connected
        )


    def acc_controller_fault_missed_deadline_callback(self, msg):
        self.get_logger().debug(f"deadline failed for ACC Controller Node fault check.")
        self.state["FAULT DETECTION: ACC Controller Node Connected"] = (
            False  # connection is lost
        )


    # DYNO: UDP DATA AVAILABLE": False,
    #     "DYNO: DYNO REQUESTED": False,
    #     "DYNO: INJECTION ACTIVE":
    # #
    def dyno_state_callback(self, msg):
        self.get_logger().debug(f"Received Dyno state")
        if msg.data == 1:
            self.state["DYNO: INJECTION ACTIVE"] = True
        else:
            self.state["DYNO: INJECTION ACTIVE"] = False


    def sim_state_callback(self, msg):
        self.get_logger().debug(f"Received Simulation state")
        if msg.data == 1:
            self.state["DYNO: UDP DATA AVAILABLE"] = True
        else:
            self.state["DYNO: UDP DATA AVAILABLE"] = False


    def dyno_req_callback(self, msg):
        self.get_logger().debug(f"Received Dyno Request state")
        if msg.data == 1:
            self.state["DYNO: DYNO REQUESTED"] = True
        else:
            self.state["DYNO: DYNO REQUESTED"] = False


    def on_connect(self, client, userdata, flags, rc):
        """Handle MQTT connection."""
        if rc == 0:
            self.get_logger().info("Connected to MQTT broker")
        else:
            self.get_logger().error(
                f"Failed to connect to MQTT broker, return code {rc}"
            )


    def on_message(self, client, userdata, msg):
        """Handle incoming MQTT messages to update switches."""
        try:
            data = json.loads(msg.payload.decode("utf-8"))
            key = data.get("key")
            value = data.get("value")  # The toggle state sent from the frontend


            # Translate the frontend key to the full state name
            full_key = self.KEY_MAPPING.get(key)


            if full_key in self.INTERFACES:
                self.update_state(full_key, value)
            else:
                self.get_logger().warn(f"Key '{key}' is not recognized or toggleable")
        except Exception as e:
            self.get_logger().error(f"Error processing message: {e}")


    def update_state(self, key, value):
        """Update a state value."""
        if key in self.state:
            self.state[key] = value
            self.get_logger().info(f"'{key}' updated to {value}")
        else:
            self.get_logger().warn(f"Attempt to update unknown state '{key}'")


    def publish_hmi_states(self):
        """Publish the current HMI states to the MQTT topic."""
        try:
            payload = json.dumps(self.state)
            self.mqtt_client.publish("hmi/cav_data", payload)
            self.get_logger().info(f"Published HMI states to hmi/cav_data")


            self.publisher_hmi_states.publish(String(data=payload))
            self.get_logger().info(
                f"Published HMI states to /HMI_states: {String(data=str(self.state))}"
            )


        except Exception as e:
            self.get_logger().error(f"Failed to publish HMI states: {e}")




def main(args=None):
    rclpy.init(args=args)
    node = HMIStatesNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.mqtt_client.loop_stop()
        node.destroy_node()
        rclpy.shutdown()




if __name__ == "__main__":
    main()


      switch (topic) {
        case 'hmi/cav_data':
          //what's published to mqtt was converted to JSON earlier. convert into a regular javascript object here
          const states = JSON.parse(value);
          setCavStates(states);
          // const DMSfaultStatus = states["FAULT DETECTION: DMS Connected"];
          // if(DMSfaultStatus == false){
          //   setdmsCavHeartbeat("False");
          // }
          // else{ //else if true?
          //   setdmsCavHeartbeat("True");
          // }


          const CAN8FaultStatus = states["FAULT DETECTION: CAN8 Connected"]; //CAN8
          if (CAN8FaultStatus == false) {
            setCAN8Heartbeat("False");
          }
          else {
            setCAN8Heartbeat("True");
          }


          const CAN3FaultStatus = states["FAULT DETECTION: CAN3 Connected"]; //CAN3
          if (CAN3FaultStatus == false) {
            setCAN3Heartbeat("False");
          }
          else {
            setCAN3Heartbeat("True");
          }




          const CAN9FaultStatus = states["FAULT DETECTION: CAN9 Connected"]; //CAN9
          if (CAN9FaultStatus == false) {
            setCAN9Heartbeat("False");
          }
          else {
            setCAN9Heartbeat("True");
          }




          const CANEVCFaultStatus = states["FAULT DETECTION: EVC CAN Connected"]; //CAN EVC
          if (CANEVCFaultStatus == false) {
            setCANEVCHeartbeat("False");
          }
          else {
            setCANEVCHeartbeat("True");
          }




          const CAN2FaultStatus = states["FAULT DETECTION: CAN2 Connected"]; //and for CAN2
          if (CAN2FaultStatus == false) {
            setCAN2Heartbeat("False");
          }
          else {
            setCAN2Heartbeat("True");
          }




          const ACCStatesFaultStatus = states["FAULT DETECTION: ACC States Node Connected"];
          if (ACCStatesFaultStatus == false) {
            setACCStatesHeartbeat("False");
          }
          else {
            setACCStatesHeartbeat("True");
          }




          const ACCControllerFaultStatus = states["FAULT DETECTION: ACC Controller Node Connected"];
          if (ACCControllerFaultStatus == false) {
            setACCControllerHeartbeat("False");
          }
          else {
            setACCControllerHeartbeat("True");
          }




          if ((ACCControllerFaultStatus && ACCStatesFaultStatus && CAN2FaultStatus && CANEVCFaultStatus && CAN3FaultStatus && CAN9FaultStatus && CAN8FaultStatus)) {
            setCAVFailure("False");
          } else {
            setCAVFailure("True");
          }




          break;
</code></pre>


<p><b>Part of the javascript code that runs on the Team Data Display:</b></p>
<p>This part reads the values sent over MQTT (which were sent as a single dictionary) and puts
them into their own respective variables:</p>

<pre><code>
      switch (topic) {
        case 'hmi/cav_data':
          //what's published to mqtt was converted to JSON earlier. convert into a regular javascript object here
          const states = JSON.parse(value);
          setCavStates(states);
          // const DMSfaultStatus = states["FAULT DETECTION: DMS Connected"];
          // if(DMSfaultStatus == false){
          //   setdmsCavHeartbeat("False");
          // }
          // else{ //else if true?
          //   setdmsCavHeartbeat("True");
          // }


          const CAN8FaultStatus = states["FAULT DETECTION: CAN8 Connected"]; //CAN8
          if (CAN8FaultStatus == false) {
            setCAN8Heartbeat("False");
          }
          else {
            setCAN8Heartbeat("True");
          }


          const CAN3FaultStatus = states["FAULT DETECTION: CAN3 Connected"]; //CAN3
          if (CAN3FaultStatus == false) {
            setCAN3Heartbeat("False");
          }
          else {
            setCAN3Heartbeat("True");
          }




          const CAN9FaultStatus = states["FAULT DETECTION: CAN9 Connected"]; //CAN9
          if (CAN9FaultStatus == false) {
            setCAN9Heartbeat("False");
          }
          else {
            setCAN9Heartbeat("True");
          }




          const CANEVCFaultStatus = states["FAULT DETECTION: EVC CAN Connected"]; //CAN EVC
          if (CANEVCFaultStatus == false) {
            setCANEVCHeartbeat("False");
          }
          else {
            setCANEVCHeartbeat("True");
          }




          const CAN2FaultStatus = states["FAULT DETECTION: CAN2 Connected"]; //and for CAN2
          if (CAN2FaultStatus == false) {
            setCAN2Heartbeat("False");
          }
          else {
            setCAN2Heartbeat("True");
          }




          const ACCStatesFaultStatus = states["FAULT DETECTION: ACC States Node Connected"];
          if (ACCStatesFaultStatus == false) {
            setACCStatesHeartbeat("False");
          }
          else {
            setACCStatesHeartbeat("True");
          }




          const ACCControllerFaultStatus = states["FAULT DETECTION: ACC Controller Node Connected"];
          if (ACCControllerFaultStatus == false) {
            setACCControllerHeartbeat("False");
          }
          else {
            setACCControllerHeartbeat("True");
          }




          if ((ACCControllerFaultStatus && ACCStatesFaultStatus && CAN2FaultStatus && CANEVCFaultStatus && CAN3FaultStatus && CAN9FaultStatus && CAN8FaultStatus)) {
            setCAVFailure("False");
          } else {
            setCAVFailure("True");
          }




          break;

</code></pre>


<p><b>I added indicators for CAV and ROS node failures to a preexisting System Diagnostics Table:</b></p>

<pre><code>
          &lt;TabsContent value="diagnostics" className="flex-1"&gt;
            &lt;Card className="h-full rounded-xl shadow"&gt;
              &lt;CardHeader&gt;
                &lt;CardTitle&gt;System Diagnostics Table&lt;/CardTitle&gt;
              &lt;/CardHeader&gt;


              &lt;CardContent className="text-sm text-muted-foreground"&gt;
                &lt;ScrollArea className="rounded-md border p-4 h-[300px]"&gt;
                  &lt;Table&gt;
                    &lt;TableHeader&gt;
                      &lt;TableRow&gt;
                        &lt;TableHead className="w-[100px]"&gt;Identifier&lt;/TableHead&gt;
                        &lt;TableHead className="text-center"&gt;Value&lt;/TableHead&gt;
                        &lt;TableHead className="text-center"&gt;Status&lt;/TableHead&gt;
                      &lt;/TableRow&gt;
                    &lt;/TableHeader&gt;
                    &lt;TableBody&gt;
                      {/* Diplay ROS and CAN fault statues */}
                      {faultStatuses.map((item) =&gt; (
                        &lt;TableRow key={item.id}&gt;
                          &lt;TableCell className="font-medium"&gt;
                            {item.name}
                          &lt;/TableCell&gt;
                          {/* Value Column: Connected or Disconnected */}
                          &lt;TableCell className="text-center"&gt;
                            {item.status === "True" ? "Connected" : "Disconnected"}
                          &lt;/TableCell&gt;
                          {/* Status Dot: Green for True, Red for False */}
                          &lt;TableCell className="text-center"&gt;
                            &lt;div
                              className={`w-4 h-4 rounded-full mx-auto ${item.status === "True" ? "bg-green-500" : "bg-red-500"
                                }`}
                            /&gt;
                          &lt;/TableCell&gt;
                        &lt;/TableRow&gt;
                      ))}


</code></pre>


	<h3>VT CRO Autonomous Workcell (Automated 3D Print Farm) Team</h3>

<p><b>Utilizing a custom trained AI model to detect 3D print failures:</b></p>
<p>Yolo v11 model was trained on Google Colab. Program takes screenshots and outputs to console.</p>

<pre><code>
from ultralytics import YOLO
import cv2
import numpy as np
import logging
import time
import os
from ultralytics.utils import LOGGER


#set up capture folder
save_dir = "captures"
os.makedirs(save_dir, exist_ok=True)
last_save_time = time.time()
save_interval = 10  # seconds

fail_last_save_time = time.time()
fail_save_interval = 3  # seconds


# Suppress Ultralytics per-frame "0: 480x640 ..." line
class SuppressDetectionLine(logging.Filter):
    def filter(self, record):
        return not record.getMessage().startswith("0: 480x640")

LOGGER.addFilter(SuppressDetectionLine())
# ------------------------------------------------------------
# Load image with OpenCV
cap = cv2.VideoCapture(0) #1 is plugged in webcam
if not cap.isOpened():
    print("Unable to open webcam")
    exit()

try:
    model = YOLO(r"<I've hidden this for privacy>\forVTCRO\Workcell-CV\Workcell-CV\YOLO\TrainedModles\best.pt")
except Exception as e:
    print(f"Error loading model")
    exit()

model.conf = 0.5 #model confidence

fail_count = 0 
while True:
    ret, frame = cap.read()
    if not ret:
        print("Can't read frames")
        break

    #save image
    current_time = time.time()
    if current_time - last_save_time >= save_interval:
        # Create a unique filename using the timestamp
        filename = f"capture_{int(current_time)}.jpg"
        filepath = os.path.join(save_dir, filename)
        
        # Save the clean frame (best for future training)
        cv2.imwrite(filepath, frame)
        print(f"Saved image: {filename}")
        # Reset the timer
        last_save_time = current_time

        

    # Run detection on the image (use predict here since it's a single frame)
    results = model.predict(source=frame, conf=0.5, verbose=False)

    failure_in_frame = False
    if results and results[0]:
        result = results[0]

        if len(result.boxes) > 0:
            failure_in_frame = True
            fail_current_time = time.time()
            if fail_current_time - fail_last_save_time >= fail_save_interval:
                #save IMAGE when FAILIURE DETECTED
                # Create a unique filename using the timestamp
                filename = f"fail_capture_{int(fail_current_time)}.jpg"
                filepath = os.path.join(save_dir, filename)
                
                # Save the boxed frame
                cv2.imwrite(filepath, frame)
                print(f"Saved image: {filename}")

                # Reset the timer
                fail_last_save_time = fail_current_time


        for box in result.boxes:
            x1, y1, x2, y2 = box.xyxy[0].cpu().numpy().astype(int)
            # Draw bounding box
            cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)

            # Optional: add class name + confidence
            cls = int(box.cls[0].cpu().numpy())
            conf = float(box.conf[0].cpu().numpy())
            label = f"{model.names[cls]} {conf:.2f}"
            cv2.putText(frame, label, (x1, y1 + 10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
        
                
        if failure_in_frame:
            fail_count += 1
        else:
            fail_count = 0

        if fail_count == 3:
            print("\n!! FAILURE DETECTED !!\n")
            fail_count = 0
        

            

            

    #save image with boxes too
    # if current_time - last_save_time >= save_interval:
    #     # Create a unique filename using the timestamp
    #     filename = f"capture_box_{int(current_time)}.jpg"
    #     filepath = os.path.join(save_dir, filename)
        
    #     # Save the boxed frame
    #     cv2.imwrite(filepath, frame)
    #     print(f"Saved image: {filename}")
        

    # Show the image with bounding boxes
    cv2.imshow("Live YOLO Detections", frame)
    if cv2.waitKey(1) == ord('q'):
        break







cap.release()
cv2.destroyAllWindows()

</code></pre>

<p><b>Pattern Detection Code for Auto Callibration of the Print Remover:</b></p>
<p>Detects a pattern that is a series of overlaid colored squares.</p>

<pre><code>
import cv2
import numpy as np

cap = cv2.VideoCapture(0) #with laptop webcam

if not cap.isOpened():
	print("Unable to open webcam")
	exit()

#color ranges. tuned to fit how it looks on my phone. may need adjustment for paper strips. HUE SATURATION VALUE.
color_ranges = {
	'green': [([50, 80, 100], [90, 255, 255])],
	'red': [([0, 100, 120], [10, 255, 255]), ([170, 150, 150], [179, 255, 255])],
	'blue': [([100, 80, 120], [130, 255, 255])],
	'yellow': [([17, 20, 100], [35, 255, 255])]
}

detection_stages = ['green', 'red', 'blue', 'yellow']
stage_index = 0

while True:
	ret, frame = cap.read()
	if not ret:
		print("Can't read frames")
		break

	#convert to HSV hue saturation value, for better color detection
	hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

	detected_centers = {}
	target_color = detection_stages[stage_index]
	hsv_ranges = color_ranges[target_color]

	#find colors, find contours, get center.
	
	combined_mask = None

	for lower_hsv, upper_hsv in hsv_ranges:
		lower_bound = np.array(lower_hsv, dtype=np.uint8)
		upper_bound = np.array(upper_hsv, dtype=np.uint8)

		mask = cv2.inRange(hsv_frame, lower_bound, upper_bound)
	
		if combined_mask is None:
			combined_mask = mask
		else:
			combined_mask = cv2.bitwise_or(combined_mask, mask)

	#hierarchy information unneeded
	contours, _ = cv2.findContours(combined_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
	
	target_detected = False

	#find largest contour first
	if contours:
		largest_contour = max(contours, key=cv2.contourArea)
		
		
		# to prevent tiny color detected boxes in the wrong places.
		if cv2.contourArea(largest_contour) > 500: # Area threshold

			target_detected = True
			M = cv2.moments(largest_contour)
				# Check if the area is not zero to avoid division by zero error
			if M["m00"] != 0:
				#get center
				cX = int(M["m10"] / M["m00"])
				cY = int(M["m01"] / M["m00"])
	
				#top-left corner of each box is where the text will be written. circle at center
				x_text, y_text, w, h = cv2.boundingRect(largest_contour)

				#store center point
				detected_centers[target_color] = (cX, cY)
		
				#draw on original frame VERIFICATION
				# Draw the contour
				cv2.drawContours(frame, [largest_contour], -1, (0, 0, 0), 2)
			
				# Draw the center point, label what color's center it is.
				cv2.circle(frame, (cX, cY), 3, (0, 0, 0), -1)
				cv2.putText(frame, f"{target_color} ({cX}, {cY})", (cX+15, cY),
				cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)
				# Put the color name and coordinates text
				cv2.putText(frame, f"{target_color} ({cX}, {cY})", (x_text+15, y_text+15),
				cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)

	if target_detected:
		print(f"Target '{target_color}' DETECTED.")
		#logic to move the calibrating head forwards will go here eventually
	else:
		print(f"Target '{target_color}' MISSING")


	#display frame VERIFICATION
	cv2.imshow('Detections', frame)
    #0xFF avoids errors on some computers according to google
	key = cv2.waitKey(1) & 0xFF 


	if key == ord('q'): 
		break
	elif key == ord(' '):
		stage_index += (1-int(stage_index / 3)) #done so that if stage_index is the final stage it won't try to go to nonexistent conseq. states
		print("Advancing to next stage.")



#when all else done
cap.release()
cv2.destroyAllWindows()

</code></pre>



<p><b>Video-Stream Sender on Raspberry Pi: Using UDP packets to transmit images taken from a webcam on a Raspberry Pi that has Klipper running on it</b></p>

<pre><code>
import requests
import socket
import time
import math

# --- Configuration ---
LAPTOP_IP = '192.168.0.104' # laptop IP 
PORT = 9999
CHUNK_SIZE = 65000 

# The URL to grab the snapshot from
SNAPSHOT_URL = 'http://192.168.0.100/webcam/?action=snapshot&bypassCache='
#'http://192.168.0.100/webcam/snapshot'

def main():
    # Create a UDP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    print(f"Fetching snapshots from {SNAPSHOT_URL}")
    print(f"Sending UDP packets to {LAPTOP_IP}:{PORT}...")

    try:
        while True:
            # --- Fetch the snapshot ---
            try:
                # Make a request to the snapshot URL
                timestamp = int(time.time() * 1000)
                url_with_cache_bypass = SNAPSHOT_URL + str(timestamp)
                r = requests.get(url_with_cache_bypass, timeout=1)
                
                # Check if the request was successful
                if r.status_code == 200:
                    # Get the raw image bytes
                    data = r.content
                else:
                    print(f"HTTP Error: {r.status_code}, skipping frame.")
                    time.sleep(0.5)
                    continue
                    
            except requests.RequestException as e:
                print(f"Network Error: {e}, skipping frame.")
                time.sleep(1) # Wait a bit before retrying
                continue

            # --- Chunk and Send ---
            total_size = len(data)
            
            # Calculate the number of chunks
            total_chunks = math.ceil(total_size / CHUNK_SIZE)
            
            if total_chunks > 255:
                print(f"Image is too large ({total_size} bytes), skipping frame.")
                continue

            # Send each chunk
            for i in range(total_chunks):
                # Calculate start and end indices for the chunk
                start = i * CHUNK_SIZE
                end = min((i + 1) * CHUNK_SIZE, total_size)
                
                # Create the packet with a 2-byte header:
                # Byte 0: Total number of chunks
                # Byte 1: Current chunk index
                header = bytes([total_chunks, i])
                packet = header + data[start:end]
                
                # Send the packet
                s.sendto(packet, (LAPTOP_IP, PORT))
            
            # Control the frame rate (e.g., 20 FPS)
            time.sleep(0.05) 

    except KeyboardInterrupt:
        print("\nStopping sender...")
    finally:
        s.close()
        print("Sender shut down.")

if __name__ == "__main__":
    main()

</code></pre>

<p><b>Video-Stream Receiver: Sitches UDP packets back together into a viewable video stream:</b></p>

<pre><code>
import cv2
import numpy as np
import socket

# --- Configuration ---
HOST = '0.0.0.0'  # Listen on all available network interfaces
PORT = 9999       # The port to listen on (must match the Pi's script)
BUFFER_SIZE = 65536 # Max UDP packet size (slightly larger than chunk size)

def main():
    # Create a UDP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    # Bind the socket to the host and port
    s.bind((HOST, PORT))
    print(f"Listening for UDP packets on {HOST}:{PORT}...")

    packet_buffer = {}  # A dictionary to hold chunks for each sender
    
    try:
        while True:
            # Receive a packet
            data, addr = s.recvfrom(BUFFER_SIZE)
            
            # Check if this is the start of a new frame from this address
            # We'll use a 3-byte header: (total_chunks, current_chunk_index)
            total_chunks = data[0]
            chunk_index = data[1]
            
            # Initialize buffer for this sender if it's the first chunk
            if chunk_index == 0:
                packet_buffer[addr] = [None] * total_chunks
            
            # Store the chunk (data[2:] is the actual image data)
            if addr in packet_buffer:
                packet_buffer[addr][chunk_index] = data[2:]

                # If we've received all chunks for this frame
                if not None in packet_buffer[addr]:
                    # Reassemble the full image data
                    full_data = b''.join(packet_buffer[addr])
                    
                    # Clean up the buffer for this address
                    del packet_buffer[addr] 
                    
                    # --- Decode and Display ---
                    try:
                        # Convert the byte data to a numpy array
                        nparr = np.frombuffer(full_data, np.uint8)
                        
                        # Decode the numpy array into an image
                        img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
                        
                        if img is not None:
                            # Display the image
                            cv2.imshow(f"Stream from {addr}", img)
                            
                            # Exit if 'q' is pressed
                            if cv2.waitKey(1) & 0xFF == ord('q'):
                                break
                        else:
                            print(f"Could not decode image from {addr}")
                            
                    except Exception as e:
                        print(f"Display Error: {e}")

    except KeyboardInterrupt:
        print("\nStopping receiver...")
    finally:
        s.close()
        cv2.destroyAllWindows()
        print("Receiver shut down.")

if __name__ == "__main__":
    main()
 

</code></pre>



    </div>

</div>

<script>
   
    function openTab(evt, tabName) {
        var i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("content-section");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].classList.remove("active");
        }


        tablinks = document.getElementsByClassName("tab-button");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].classList.remove("active");
        }


        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");
    }
</script>

</body>
</html>